<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçäÂä†ÂØÜÂ∑•ÂÖ∑</title>
    <style>
        /*
         * Modern, Apple‚Äëinspired UI for the Emoji encryption tool.  The design
         * is clean and minimal with a light background, gentle shadows and
         * rounded corners reminiscent of Apple‚Äôs design language.  Colours are
         * subtle and consistent, emphasising clarity and ease of use.  The
         * interface scales gracefully across different viewport sizes.
         */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            /* Use the system font stack for better cross‚Äëplatform appearance */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
                Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            /* Light, neutral background similar to apple.com */
            background-color: #f5f5f7;
            color: #1d1d1f;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            background-color: #ffffff;
            border: 1px solid #e5e5ea;
            border-radius: 16px;
            /* Soft shadow for subtle depth */
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            padding: 32px;
            width: 600px;
            max-width: 90%;
        }

        h1 {
            text-align: center;
            margin: 0 0 24px;
            font-size: 32px;
            font-weight: 600;
            /* Use a gentle gradient reminiscent of Apple‚Äôs colourful text
               occasionally seen in marketing materials */
            background: linear-gradient(90deg, #6e6ef7, #87a2f9, #a5c7ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        textarea,
        input[type="password"] {
            background-color: #f2f3f7;
            border: 1px solid #d7d8dc;
            border-radius: 8px;
            padding: 12px;
            color: #1d1d1f;
            width: 100%;
            font-size: 16px;
            resize: vertical;
            /* Provide a subtle inner shadow when focused */
            transition: box-shadow 0.2s ease, border-color 0.2s ease;
        }
        textarea:focus,
        input[type="password"]:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
        }

        .buttons {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            margin-top: 24px;
        }

        button {
            flex: 1 1 calc(33% - 10px);
            margin: 5px;
            padding: 14px 24px;
            border: none;
            border-radius: 12px;
            /* Apple‚Äëstyle blue gradient reminiscent of iOS primary buttons */
            background: linear-gradient(180deg, #007aff 0%, #5ac8fa 100%);
            color: #ffffff;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 0 4px 10px rgba(0, 122, 255, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(0, 122, 255, 0.4);
        }

        #output,
        #error {
            padding: 14px;
            min-height: 50px;
            border-radius: 8px;
            background-color: #f2f3f7;
            border: 1px solid #e5e5ea;
            word-break: break-all;
            font-size: 15px;
        }

        /* Colour overrides for output and error messages */
        #output {
            margin-top: 0;
            color: #28a745;
        }

        #error {
            margin-top: 20px;
            color: #d0021b;
        }

        /* Layout wrapper for the output area and copy button.  Position
           relative so the copy button can be absolutely positioned within
           the wrapper. */
        .output-wrapper {
            position: relative;
            margin-top: 28px;
        }

        /* Adjust the output container to leave space for the copy button on
           the right so text does not overlap. */
        .output-wrapper #output {
            padding-right: 80px;
        }

        /* Style for the one‚Äëclick copy button.  Absolutely position it in
           the top‚Äëright corner of the output wrapper.  It uses the same
           gradient and interactive ripple as the primary buttons but is
           slightly smaller. */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 8px 18px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(180deg, #007aff 0%, #5ac8fa 100%);
            color: #ffffff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0, 122, 255, 0.3);
        }

        .copy-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 10px rgba(0, 122, 255, 0.4);
        }

        /* Aurora text effect: animated pastel gradient that gently flows
           across the text.  The colours are softened to suit a light
           interface while still providing a sense of movement. */
        .aurora-text {
            position: relative;
            display: inline-block;
            background: linear-gradient(45deg, #a18fff, #c4b6ff, #bfe3ff, #9acbff);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: aurora 12s ease infinite;
        }

        @keyframes aurora {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Interactive hover button effect: radial ripple that follows the
           mouse pointer, creating a sense of depth and interactivity. */
        button.interactive-button {
            /* Each interactive button has a custom property to track the
               ripple origin.  Default to the centre so that the gradient
               originates from the middle when idle.  We also position
               them relative to enable the pseudo‚Äëelement overlay. */
            --mouse-x: 50%;
            --mouse-y: 50%;
            position: relative;
            overflow: hidden;
        }
        button.interactive-button::after {
            content: "";
            position: absolute;
            left: var(--mouse-x);
            top: var(--mouse-y);
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            /* Softer radial highlight for a light interface */
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0) 70%);
            opacity: 0;
            transition: width 0.4s ease, height 0.4s ease, opacity 0.4s;
            pointer-events: none;
        }
        button.interactive-button:hover::after {
            width: 220px;
            height: 220px;
            opacity: 1;
        }


        /* Responsive adjustments for mobile devices.  When the viewport
           width is narrow (e.g. phones), stack the buttons vertically,
           reduce padding and adjust font sizes for better legibility. */
        @media (max-width: 600px) {
            .container {
                width: 100%;
                max-width: 100%;
                padding: 24px;
                border-radius: 0;
            }
            h1 {
                font-size: 26px;
            }
            .buttons {
                flex-direction: column;
                align-items: stretch;
            }
            button {
                flex: 1 1 100%;
                margin: 6px 0;
                font-size: 15px;
            }
            textarea,
            input[type="password"] {
                font-size: 15px;
            }
            #output,
            #error {
                font-size: 14px;
                padding: 12px;
            }

            .output-wrapper {
                margin-top: 20px;
            }

            .copy-btn {
                top: 4px;
                right: 4px;
                padding: 6px 14px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1><span class="aurora-text">Emoji Âä†ÂØÜÂ∑•ÂÖ∑</span></h1>
        <div class="input-group">
            <textarea id="inputText" placeholder="ËæìÂÖ•ÊñáÊú¨..."></textarea>
            <input type="password" id="passphrase" placeholder="ËæìÂÖ•Âä†ÂØÜÂØÜÈí•" />
        </div>
        <div class="buttons">
            <button id="encodeNoKeyBtn" class="interactive-button">Êó†ÂØÜÈí•Âä†ÂØÜ</button>
            <button id="encryptToEmojiBtn" class="interactive-button">Â∏¶ÂØÜÈí•Âä†ÂØÜ</button>
            <button id="decryptFromEmojiBtn" class="interactive-button">Ëß£ÂØÜ Emoji</button>
        </div>
        <!-- Wrap the output and copy button together for easier layout -->
        <div class="output-wrapper">
            <div id="output"></div>
            <button id="copyBtn" class="copy-btn interactive-button" type="button">Â§çÂà∂</button>
        </div>
        <div id="error"></div>
    </div>

    <script type="module">
        // Import the emoji codec API from our ESM module.  Note that we import
        // decodeNoKey as well so the decode button can fall back to the
        // no‚Äëkey mode if no passphrase is provided.  This mirrors the
        // behaviour of our Python reference implementation.
        import { BaseEmoji, encodeNoKey, decodeNoKey, decryptFromEmoji, encryptToEmoji } from "./index.mjs";
        
        console.log("emoji module loaded");
        const alphabet = await fetch("./base-emoji-alphabet-v1-256.json")
            .then(res => res.json())
            .then(data => new BaseEmoji(data.index_to_emoji))
            .catch(err => {
                console.error("Error loading alphabet:", err);
            });
        
        const inputText = document.getElementById("inputText");
        const passphrase = document.getElementById("passphrase");
        const output = document.getElementById("output");
        const error = document.getElementById("error");
        const copyBtn = document.getElementById("copyBtn");

        // Track the current result for quick copying.  Whenever a new
        // encryption or decryption completes, this variable is updated
        // with the raw result string (without the label).  The copy
        // button uses this value when copying to clipboard.
        let currentResult = "";

        // Attach interactive hover effect to each button.  On mouse move
        // we update the CSS custom properties --mouse-x and --mouse-y on
        // the button element.  These variables control the radial ripple
        // position defined in the CSS.  When the mouse leaves the button,
        // reset the variables to the centre of the element.
        document.querySelectorAll('button.interactive-button').forEach(btn => {
            btn.addEventListener('mousemove', e => {
                const rect = btn.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                btn.style.setProperty('--mouse-x', `${x}px`);
                btn.style.setProperty('--mouse-y', `${y}px`);
            });
            btn.addEventListener('mouseleave', () => {
                // Reset the ripple to centre when the pointer leaves
                btn.style.setProperty('--mouse-x', '50%');
                btn.style.setProperty('--mouse-y', '50%');
            });
        });

        // Êó†ÂØÜÈí•Âä†ÂØÜ
        document.getElementById("encodeNoKeyBtn").addEventListener("click", () => {
            const text = inputText.value.trim();
            if (!text) {
                error.textContent = "ËØ∑ËæìÂÖ•ÊñáÊú¨ËøõË°åÂä†ÂØÜÔºÅ";
                return;
            }
            try {
                console.log("Encrypting with NoKey:", text);
                const raw = encodeNoKey(text, alphabet);
                // Always prefix the result with the üçä emoji
                const emoji = 'üçä' + raw;
                currentResult = emoji;
                output.textContent = `Âä†ÂØÜÁªìÊûúÔºö${emoji}`;
                error.textContent = "";
            } catch (e) {
                error.textContent = `Âä†ÂØÜÂ§±Ë¥•Ôºö${e.message}`;
                console.error(e);
            }
        });

        // Â∏¶ÂØÜÈí•Âä†ÂØÜ
        document.getElementById("encryptToEmojiBtn").addEventListener("click", async () => {
            const text = inputText.value.trim();
            const key = passphrase.value.trim();
            if (!text || !key) {
                error.textContent = "ËØ∑ËæìÂÖ•ÊñáÊú¨ÂíåÂØÜÈí•ÔºÅ";
                return;
            }
            try {
                console.log("Encrypting with key:", text);
                const raw = await encryptToEmoji(text, key, alphabet);
                const emoji = 'üçä' + raw;
                currentResult = emoji;
                output.textContent = `Âä†ÂØÜÁªìÊûúÔºö${emoji}`;
                error.textContent = "";
            } catch (e) {
                error.textContent = `Âä†ÂØÜÂ§±Ë¥•Ôºö${e.message}`;
                console.error(e);
            }
        });

        // Ëß£ÂØÜ Emoji
        document.getElementById("decryptFromEmojiBtn").addEventListener("click", async () => {
            const emojiStr = inputText.value.trim();
            const key = passphrase.value.trim();
            if (!emojiStr) {
                error.textContent = "ËØ∑ËæìÂÖ•ÂæÖËß£ÂØÜÁöÑ EmojiÔºÅ";
                return;
            }
            try {
                console.log("Decrypting emoji:", emojiStr);
                let decrypted;
                // Strip the üçä prefix if present before decoding
                let toDecode = emojiStr;
                if (toDecode.startsWith('üçä')) {
                    toDecode = toDecode.slice(1);
                }
                if (key) {
                    // Decrypt using the passphrase via AES‚ÄëGCM
                    decrypted = await decryptFromEmoji(toDecode, key, alphabet);
                } else {
                    // Fallback to no‚Äëkey mode if no passphrase is supplied
                    decrypted = decodeNoKey(toDecode, alphabet);
                }
                currentResult = decrypted;
                output.textContent = `Ëß£ÂØÜÁªìÊûúÔºö${decrypted}`;
                error.textContent = "";
            } catch (e) {
                error.textContent = `Ëß£ÂØÜÂ§±Ë¥•Ôºö${e.message}`;
                console.error(e);
            }
        });

        // Copy result to clipboard when the user clicks the copy button.  If
        // there is no result yet, show an error message.  When copying
        // succeeds, temporarily change the button label to indicate
        // success.
        copyBtn.addEventListener('click', async () => {
            if (!currentResult) {
                error.textContent = "Ê≤°ÊúâÂèØÂ§çÂà∂ÁöÑÂÜÖÂÆπÔºÅ";
                return;
            }
            try {
                await navigator.clipboard.writeText(currentResult);
                const originalLabel = copyBtn.textContent;
                copyBtn.textContent = "Â∑≤Â§çÂà∂";
                // Clear any previous error
                error.textContent = "";
                setTimeout(() => {
                    copyBtn.textContent = originalLabel;
                }, 2000);
            } catch (err) {
                error.textContent = "Â§çÂà∂Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊµèËßàÂô®ËÆæÁΩÆ";
                console.error(err);
            }
        });
    </script>

</body>
</html>
