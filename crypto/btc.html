<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>åŠ å¯†è´§å¸å®æ—¶äº¤æ˜“ + AIæ™ºèƒ½åˆ†æé¢æ¿</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" />
    <link rel="preconnect" href="https://unpkg.com" />
    <style>
        :root {
            --bg: #0b0f14;
            --panel: #111824;
            --panel-light: #1a2230;
            --muted: #94a3b8;
            --text: #e2e8f0;
            --accent: #60a5fa;
            --buy: #22c55e;
            --sell: #ef4444;
            --info: #38bdf8;
            --warn: #facc15;
            --shadow: 0 6px 24px rgba(0, 0, 0, .25);
        }

        * { box-sizing: border-box }

        html,
        body {
            height: 100%;
            margin: 0;
            background: linear-gradient(180deg, #0b0f14, #0f172a);
            color: var(--text);
            font: 14px/1.5 system-ui, -apple-system, Segoe UI, Inter, Roboto, Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* --- NEW LAYOUT STRUCTURE --- */
        .wrap { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 16px;
        }
        .main-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: 1fr; /* Mobile-first: single column */
        }
        /* Tablet and small desktop: 2 columns */
        @media (min-width: 992px) {
            .main-grid {
                grid-template-columns: minmax(0, 2fr) minmax(340px, 1fr);
            }
        }
        /* Large desktop: 3 columns for optimal data view */
        @media (min-width: 1280px) {
            .main-grid {
                grid-template-columns: minmax(0, 3fr) minmax(320px, 1fr) minmax(320px, 1fr);
            }
        }

        .main-content, .ai-column, .data-column {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        header { 
            display: flex; 
            gap: 12px; 
            flex-wrap: wrap; 
            align-items: center; 
            justify-content: space-between; 
            margin-bottom: 16px;
        }
        .title-container { display: flex; align-items: center; gap: 12px; }
        .title { font-weight: 800; font-size: 20px; }
        .status-indicator { width: 10px; height: 10px; border-radius: 50%; transition: all 0.3s ease; }
        .status-connected { background-color: var(--buy); box-shadow: 0 0 8px var(--buy); }
        .status-connecting { background-color: var(--warn); box-shadow: 0 0 8px var(--warn); animation: pulse 1.5s infinite; }
        .status-disconnected { background-color: var(--sell); box-shadow: 0 0 8px var(--sell); }

        .panel { background: var(--panel); border: 1px solid #1f2937; border-radius: 14px; box-shadow: var(--shadow); overflow: hidden; display: flex; flex-direction: column; }
        
        .toolbar { 
            display: flex; 
            gap: 12px; 
            flex-wrap: wrap; 
            align-items: center; 
            padding: 12px 16px;
            flex-direction: row;
        }
        .toolbar-group { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        .toolbar label { color: var(--muted); font-weight: 600; font-size: 13px; }
        input, select, button { background: #0b1220; border: 1px solid #1f2937; color: var(--text); padding: 8px 12px; border-radius: 10px; transition: all 0.2s ease; }
        select:hover, button:hover:not(:disabled) { border-color: var(--accent); }
        button:disabled { opacity: .5; cursor: not-allowed; }
        @media (max-width: 767px) {
            .toolbar { flex-direction: column; align-items: stretch; }
            .toolbar-group { flex-direction: column; align-items: stretch; width: 100%;}
            .toolbar-group > div { display: flex; flex-direction: column; }
            .toolbar-group select { width: 100%; }
            .toolbar-spacer { display: none; }
        }


        .statbar { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); 
            gap: 16px; 
            padding: 16px;
        }
        .stat { background: var(--panel-light); border: 1px solid #2a3447; border-radius: 12px; padding: 12px; transition: all 0.3s ease; }
        .stat:hover { transform: translateY(-2px); border-color: var(--accent); }
        .stat .k { font-size: 12px; color: var(--muted); margin-bottom: 4px; }
        .stat .v { font-size: 18px; font-weight: 800; }

        .chart-container { position: relative; padding: 16px; background: linear-gradient(180deg, #0b1220, #0b0f14); min-height: 300px; flex-grow: 1; }
        .chart-container h3 { margin: 0 0 8px 4px; font-weight: 700; color: var(--muted); font-size: 13px; flex-shrink: 0; }
        .chart-wrapper { flex-grow: 1; min-height: 250px; }
        .badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; border: 1px solid #263144; background: #0b1220; color: var(--muted) }
        .buy { color: var(--buy) }
        .sell { color: var(--sell) }

        /* AI Panel Styles */
        .ai-panel-header { padding: 16px; background: linear-gradient(135deg, rgba(96, 165, 250, 0.1), transparent); border-bottom: 1px solid #1f2937; }
        .ai-panel-header h3 { margin: 0; font-size: 16px; font-weight: 800; display: flex; align-items: center; gap: 8px; }
        .ai-summary { padding: 16px; background: var(--panel-light); text-align: center; }
        .ai-summary-title { font-size: 13px; font-weight: 600; color: var(--muted); margin-bottom: 8px; }
        .ai-summary-text { font-size: 18px; font-weight: 800; line-height: 1.4; min-height: 50px; word-break: break-word; }
        
        .ai-compass { padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 12px; }
        .compass-container { position: relative; width: 150px; height: 75px; overflow: hidden; }
        .compass-bg { width: 150px; height: 150px; border-radius: 50%; background: conic-gradient(from -90deg, var(--sell) 0%, var(--warn) 50%, var(--buy) 100%); position: absolute; top: 0; }
        .compass-mask { position: absolute; width: 130px; height: 130px; background: var(--panel); border-radius: 50%; top: 10px; left: 10px; }
        .compass-needle { position: absolute; width: 2px; height: 65px; background: var(--text); bottom: 10px; left: 74px; transform-origin: bottom; transition: transform 0.5s ease-out; }
        .compass-center { position: absolute; width: 10px; height: 10px; background: var(--text); border-radius: 50%; bottom: 5px; left: 70px; }
        .compass-score { position: absolute; bottom: 15px; width: 100%; text-align: center; font-size: 24px; font-weight: 900; }
        .compass-label { font-size: 12px; color: var(--muted); }

        .ai-breakdown { padding: 0 16px 16px; display: flex; flex-direction: column; gap: 10px; }
        .indicator-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; }
        .indicator-name { font-weight: 600; color: var(--muted); }
        .indicator-signal { padding: 3px 8px; border-radius: 6px; font-weight: 700; font-size: 12px; }
        .indicator-signal.buy { background: rgba(34, 197, 94, 0.2); color: var(--buy); }
        .indicator-signal.sell { background: rgba(239, 68, 68, 0.2); color: var(--sell); }
        .indicator-signal.neutral { background: rgba(148, 163, 184, 0.2); color: var(--muted); }
        
        .metrics-grid { padding: 16px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .gemini-prediction { padding: 16px; border-top: 1px solid #1f2937; }
        .gemini-prediction .k { font-size: 13px; font-weight: 700; color: var(--accent); margin-bottom: 6px; }
        .gemini-prediction .v { font-size: 14px; color: var(--text); }

        /* On-chain Intel & Data Panels */
        .data-panel-content { padding: 16px; display: grid; grid-template-columns: 1fr; gap: 16px; }
        .intel-stat { display: flex; align-items: flex-start; gap: 12px; }
        .intel-icon { font-size: 24px; margin-top: 4px; }
        .intel-value { font-size: 16px; font-weight: 700; }
        .intel-label { font-size: 12px; color: var(--muted); }
        .intel-trend { font-weight: 600; font-size: 14px; }

        .whale-wallet-container { border-bottom: 1px solid #1f2937; padding-bottom: 12px; margin-bottom: 12px; }
        .whale-wallet-container:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .whale-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .whale-name { font-weight: 700; font-size: 14px; color: var(--accent); }
        .whale-balance { font-weight: 700; font-size: 14px; }
        .whale-tx { display: flex; align-items: center; gap: 12px; font-size: 13px; margin-top: 8px; }
        .whale-tx-dir { font-size: 20px; }
        .whale-tx-details { flex-grow: 1; }
        .whale-tx-amount { font-weight: 700; }
        .whale-tx-meta { font-size: 11px; color: var(--muted); }
        .whale-tx-meta a { color: var(--accent); text-decoration: none; }
        .whale-tx-meta a:hover { text-decoration: underline; }
        
        .dex-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; }
        .dex-name { font-weight: 600; color: var(--text); }
        .dex-volume-details { text-align: right; }
        .dex-volume { font-weight: 700; }
        .dex-change { font-size: 11px; }

        .news-list { padding: 16px; max-height: 280px; overflow-y: auto; flex-grow: 1; }
        .news-item { margin-bottom: 12px; }
        .news-title { font-weight: 600; color: var(--text); text-decoration: none; display: block; margin-bottom: 4px; }
        .news-title:hover { color: var(--accent); }
        .news-source { font-size: 12px; color: var(--muted); }

        /* Loader & Error Styles */
        .loader-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(11, 15, 20, 0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; border-radius: 14px; opacity: 0; visibility: hidden; transition: all 0.3s; }
        .loader-overlay.visible { opacity: 1; visibility: visible; }
        .loader { width: 48px; height: 48px; border: 3px solid var(--accent); border-bottom-color: transparent; border-radius: 50%; display: inline-block; animation: rotation 1s linear infinite; }
        .loader-text { color: var(--muted); margin-top: 10px; font-size: 12px; }
        .error-message { color: var(--sell); text-align: center; font-weight: 600; padding: 20px; margin: auto; }

        .gemini-button-container { padding: 0 16px 16px; }
        .gemini-button {
            width: 100%;
            padding: 10px;
            font-weight: 700;
            background: linear-gradient(90deg, var(--accent), var(--info));
            border: none;
            color: #fff;
            cursor: pointer;
        }
        .gemini-button:disabled { background: var(--panel-light); color: var(--muted); }

        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.8; transform: scale(1.02); } }
        
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <div class="title-container">
                <div class="title">ğŸ“Š åŠ å¯†è´§å¸AIæ™ºèƒ½åˆ†æé¢æ¿</div>
                <div id="statusIndicator" class="status-indicator" title="æ•°æ®æµè¿æ¥çŠ¶æ€"></div>
            </div>
            <div class="legend">
                <span class="badge">VWAP</span>
                <span class="badge" style="color: var(--buy)">ä¹°</span>
                <span class="badge" style="color: var(--sell)">å–</span>
            </div>
        </header>

        <div class="panel toolbar">
            <div class="toolbar-group">
                <div><label>ğŸ“ˆ äº¤æ˜“å¯¹</label><select id="symbol"></select></div>
                <div><label>ğŸ“Š æˆäº¤èšåˆ</label><select id="bucket"></select></div>
                <div><label>ğŸ• Kçº¿å‘¨æœŸ</label><select id="kInterval"></select></div>
            </div>
            <div style="flex:1" class="toolbar-spacer"></div>
            <div class="toolbar-group">
                <button id="pauseBtn" title="æš‚åœæ•°æ®æ›´æ–°">â¯ï¸ æš‚åœ</button>
                <button id="resetBtn" title="é‡æ–°è¿æ¥æ•°æ®æº">ğŸ”„ é‡è¿</button>
            </div>
        </div>

        <div class="panel statbar">
            <div class="stat"><div class="k">æœ€æ–°ä»·</div><div class="v" id="lastPrice">-</div></div>
            <div class="stat"><div class="k">24h æ¶¨è·Œå¹…</div><div class="v" id="change24h">-</div></div>
            <div class="stat"><div class="k">å‘¨æœŸä¸»åŠ¨ä¹°é‡</div><div class="v buy" id="buyNow">-</div></div>
            <div class="stat"><div class="k">å‘¨æœŸä¸»åŠ¨å–é‡</div><div class="v sell" id="sellNow">-</div></div>
            <div class="stat"><div class="k">å‘¨æœŸå‡€å€¼</div><div class="v" id="netNow">-</div></div>
        </div>

        <!-- NEW: Re-organized grid for responsiveness -->
        <div class="main-grid">
            <!-- Column 1: Main Charts -->
            <div class="main-content">
                <div class="panel chart-container">
                    <h3 id="klineTitle">ä»·æ ¼ K çº¿</h3>
                    <div class="chart-wrapper" id="kchart"></div>
                    <div class="loader-overlay" id="kchartLoader"><span class="loader"></span></div>
                </div>
                 <div class="panel chart-container">
                    <h3>ä¸»åŠ¨ä¹°/å– & å‡€ä¸»åŠ¨ä½“é‡</h3>
                    <div class="chart-wrapper" id="flowNetContainer">
                        <canvas id="flowNetChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Column 2: AI Analysis -->
            <div class="ai-column">
                <div class="panel">
                    <div class="ai-panel-header"><h3>ğŸ§  AI æ™ºèƒ½åˆ†æå¼•æ“</h3></div>
                    <div id="aiAnalysisContainer"></div>
                    <div class="ai-breakdown" id="aiBreakdownContainer"></div>
                    <div class="gemini-button-container">
                        <button id="gemini-analysis-btn" class="gemini-button">âœ¨ ç”ŸæˆAIæ·±åº¦åˆ†æ</button>
                    </div>
                    <div class="loader-overlay" id="predictionLoader">
                        <div><span class="loader"></span><div class="loader-text">AI åˆ†æä¸­...</div></div>
                    </div>
                </div>
                <div class="panel" id="aiMetricsPanel">
                    <div class="ai-panel-header"><h3>ğŸ¯ AI å…³é”®æŒ‡æ ‡ä¸é¢„æµ‹</h3></div>
                    <div class="metrics-grid" id="aiMetricsContainer"></div>
                    <div id="geminiPredictionContainer"></div>
                </div>
            </div>

            <!-- Column 3: On-chain & Market Data -->
            <div class="data-column">
                <div class="panel">
                     <div class="ai-panel-header"><h3>ğŸ”— é“¾ä¸Šæƒ…æŠ¥ (DefiLlama)</h3></div>
                     <div class="data-panel-content" id="onchainIntelGrid"></div>
                </div>
                <div class="panel">
                    <div class="ai-panel-header"><h3>ğŸ“ˆ DEX 24häº¤æ˜“é‡æ’è¡Œ</h3></div>
                    <div class="data-panel-content" id="dexVolumeList"></div>
                </div>
                <div class="panel">
                    <div class="ai-panel-header"><h3>ğŸ³ å·¨é²¸é’±åŒ…åŠ¨æ€ (ETH)</h3></div>
                    <div class="data-panel-content" id="whaleActivityList"></div>
                </div>
                <div class="panel">
                     <div class="ai-panel-header"><h3>ğŸ“° å¸‚åœºå‰æ²¿èµ„è®¯</h3></div>
                     <div class="news-list" id="newsListContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/lightweight-charts@4.1.2/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <script>
        (function () {
            'use strict';

            // --- 1. CONFIGURATION & STATE ---
            const CONFIG = {
                api: {
                    binanceRest: 'https://api3.binance.com/api/v3',
                    binanceWs: 'wss://stream.binance.com:9443/stream',
                    defiLlama: 'https://api.llama.fi',
                    cryptoCompare: 'https://min-api.cryptocompare.com/data/v2/news/',
                    etherscan: 'https://api.etherscan.io/api'
                },
                etherscanApiKey: 'YourApiKeyToken', 
                whaleWallets: [
                    { address: '0xab5801a7d398351b8be11c439e05c5b3259aec9b', name: 'ä¸»é’±åŒ… (0xab58)' },
                    { address: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', name: 'vitalik.eth' }
                ],
                symbols: { 
                    'BTCUSDT': { name: 'BTC/USDT', icon: 'â‚¿', chain: null }, 
                    'ETHUSDT': { name: 'ETH/USDT', icon: 'Î', chain: 'Ethereum' }, 
                    'SOLUSDT': { name: 'SOL/USDT', icon: 'â˜€ï¸', chain: 'Solana' }, 
                    'DOGEUSDT': { name: 'DOGE/USDT', icon: 'Ã', chain: null }, 
                    'TAOUSDT': { name: 'TAO/USDT', icon: 'ğŸ§ ', chain: null } 
                },
                buckets: { '1åˆ†é’Ÿ': 60000, '5åˆ†é’Ÿ': 300000, '15åˆ†é’Ÿ': 900000 },
                klineIntervals: { '1m': '1åˆ†é’Ÿ', '5m': '5åˆ†é’Ÿ', '15m': '15åˆ†é’Ÿ', '30m': '30åˆ†é’Ÿ', '1h': '1å°æ—¶', '4h': '4å°æ—¶', '1d': '1æ—¥' },
                defaults: { symbol: 'ETHUSDT', bucketMs: 60000, kInterval: '15m' },
                charts: { maxDataPoints: 300, updateThrottleMs: 250 }
            };

            const STATE = {
                symbol: CONFIG.defaults.symbol,
                bucketMs: CONFIG.defaults.bucketMs,
                kInterval: CONFIG.defaults.kInterval,
                ws: null, isPaused: false, reconnectTimer: null,
                klineHistory: [], buckets: new Map(),
                isRafPending: false, predictionUpdateInterval: null,
                onchainIntel: { stablecoinNetflow: 0, chainTvlChange: null, chainDexVolume: null },
                whaleData: [],
                dexVolumes: [],
                lastAnalysis: {},
                news: []
            };

            // --- 2. DOM ELEMENTS & UI HELPER ---
            const $ = (id) => document.getElementById(id);
            const DOM = {
                symbol: $('symbol'), bucket: $('bucket'), kInterval: $('kInterval'),
                pauseBtn: $('pauseBtn'), resetBtn: $('resetBtn'),
                lastPrice: $('lastPrice'), change24h: $('change24h'), buyNow: $('buyNow'), sellNow: $('sellNow'), netNow: $('netNow'),
                statusIndicator: $('statusIndicator'),
                klineTitle: $('klineTitle'),
                kchartContainer: $('kchart'),
                kchartLoader: $('kchartLoader'), predictionLoader: $('predictionLoader'),
                aiAnalysisContainer: $('aiAnalysisContainer'), aiBreakdownContainer: $('aiBreakdownContainer'),
                aiMetricsContainer: $('aiMetricsContainer'),
                geminiPredictionContainer: $('geminiPredictionContainer'),
                onchainIntelGrid: $('onchainIntelGrid'),
                newsListContainer: $('newsListContainer'),
                whaleActivityList: $('whaleActivityList'),
                geminiBtn: $('gemini-analysis-btn'),
                dexVolumeList: $('dexVolumeList')
            };

            const UI = {
                toggleLoader: (loader, show) => loader.classList.toggle('visible', show),
                updateStatus: (status) => {
                    DOM.statusIndicator.className = `status-indicator status-${status}`;
                    DOM.statusIndicator.title = `æ•°æ®æµ: ${status}`;
                },
                populateSelects: () => {
                    const createOptions = (data, selected) => Object.entries(data).map(([v, t]) => `<option value="${v}" ${v==selected?'selected':''}>${t}</option>`).join('');
                    const symbolOpts = Object.entries(CONFIG.symbols).map(([v, {name, icon}]) => `<option value="${v}" ${v==STATE.symbol?'selected':''}>${icon} ${name}</option>`).join('');
                    DOM.symbol.innerHTML = symbolOpts;
                    DOM.bucket.innerHTML = createOptions(CONFIG.buckets, STATE.bucketMs);
                    DOM.kInterval.innerHTML = createOptions(CONFIG.klineIntervals, STATE.kInterval);
                },
                updateTitles: () => {
                    const { name, icon } = CONFIG.symbols[STATE.symbol];
                    document.title = `${icon} ${name} AIæ™ºèƒ½åˆ†æé¢æ¿`;
                    DOM.klineTitle.textContent = `${icon} ${name} ä»·æ ¼ K çº¿ (Binance)`;
                    document.querySelector('.title').textContent = `ğŸ“Š ${name} AIæ™ºèƒ½åˆ†æé¢æ¿`;
                },
                renderAiAnalysis: (score, summary) => {
                    const scoreText = score !== null ? score : '...';
                    const needleRotation = score !== null ? (score / 100) * 180 - 90 : 0;
                    DOM.aiAnalysisContainer.innerHTML = `
                        <div class="ai-summary">
                            <div class="ai-summary-title">AI æ ¸å¿ƒè§‚ç‚¹</div>
                            <div class="ai-summary-text" id="ai-summary-text">${summary}</div>
                        </div>
                        <div class="ai-compass">
                            <div class="compass-container">
                                <div class="compass-bg"></div>
                                <div class="compass-mask"></div>
                                <div class="compass-needle" style="transform: rotate(${needleRotation}deg);"></div>
                                <div class="compass-center"></div>
                                <div class="compass-score">${scoreText}</div>
                            </div>
                            <div class="compass-label">AI ç»¼åˆåˆ†æç½—ç›˜</div>
                        </div>`;
                },
                renderAiBreakdown: (breakdown) => {
                    const signalMap = { buy: 'çœ‹æ¶¨', sell: 'çœ‹è·Œ', neutral: 'ä¸­æ€§' };
                    DOM.aiBreakdownContainer.innerHTML = Object.entries(breakdown).map(([key, { signal, reason }]) => `
                        <div class="indicator-row" title="${reason}">
                            <span class="indicator-name">${key.toUpperCase()}</span>
                            <span class="indicator-signal ${signal}">${signalMap[signal]}</span>
                        </div>`).join('');
                },
                 renderAiMetrics: (metrics) => {
                    const formatPrice = (price) => price ? `$${price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 4})}` : '-';
                    const trendInfo = { bullish: 'ğŸš€ çœ‹æ¶¨', bearish: 'ğŸ“‰ çœ‹è·Œ', neutral: 'â¡ï¸ éœ‡è¡' };
                    const riskInfo = { low: 'ğŸŸ¢ ä½', medium: 'ğŸŸ¡ ä¸­', high: 'ğŸ”´ é«˜' };
                    
                    DOM.aiMetricsContainer.innerHTML = `
                        <div class="stat"><div class="k">ğŸ“ˆ å»ºè®®ä¹°å…¥ä»·</div><div class="v buy">${formatPrice(metrics.buyPrice)}</div></div>
                        <div class="stat"><div class="k">ğŸ“‰ å»ºè®®å–å‡ºä»·</div><div class="v sell">${formatPrice(metrics.sellPrice)}</div></div>
                        <div class="stat"><div class="k">ğŸ›¡ï¸ æ”¯æ’‘ä½</div><div class="v">${formatPrice(metrics.support)}</div></div>
                        <div class="stat"><div class="k">âš¡ é˜»åŠ›ä½</div><div class="v">${formatPrice(metrics.resistance)}</div></div>
                        <div class="stat"><div class="k">ğŸ“Š è¶‹åŠ¿ä¿¡å·</div><div class="v">${trendInfo[metrics.trend] || '-'}</div></div>
                        <div class="stat"><div class="k">âš ï¸ é£é™©ç­‰çº§</div><div class="v">${riskInfo[metrics.risk] || '-'}</div></div>
                        <div class="stat" colspan="2"><div class="k">ğŸ˜± è´ªå©ªææƒ§æŒ‡æ•°</div><div class="v">${metrics.fearGreedIndex ?? '-'}</div></div>
                    `;
                },
                renderGeminiPrediction: (prediction) => {
                    DOM.geminiPredictionContainer.innerHTML = `
                        <div class="gemini-prediction">
                            <div class="k">ğŸ”® Gemini ä»·æ ¼é¢„æµ‹</div>
                            <div class="v">${prediction.pricePrediction || 'æš‚æ— é¢„æµ‹'} (ä¿¡å¿ƒ: ${prediction.confidence || 'N/A'})</div>
                            <div class="k" style="margin-top: 10px;">ğŸ’¡ ç­–ç•¥å»ºè®®</div>
                            <div class="v">${prediction.strategySuggestion || 'æš‚æ— å»ºè®®'}</div>
                        </div>
                    `;
                },
                renderOnchainIntel: (intel) => {
                    const formatLargeNumber = (num) => {
                        if (num === null || num === undefined) return '-';
                        if (Math.abs(num) >= 1e9) return `${(num / 1e9).toFixed(2)}B`;
                        if (Math.abs(num) >= 1e6) return `${(num / 1e6).toFixed(2)}M`;
                        if (Math.abs(num) >= 1e3) return `${(num / 1e3).toFixed(2)}K`;
                        return num.toFixed(2);
                    };
                    const formatPercent = (num) => {
                        if (num === null || num === undefined) return '-';
                        return `${(num * 100).toFixed(2)}%`;
                    };
                    const trendArrow = (val) => val > 0 ? 'ğŸ”¼' : 'ğŸ”½';
                    const trendColor = (val) => val > 0 ? 'var(--buy)' : 'var(--sell)';

                    let html = `
                        <div class="intel-stat">
                            <div class="intel-icon">ğŸ’µ</div>
                            <div>
                                <div class="intel-value">${formatLargeNumber(intel.stablecoinNetflow)} <span class="intel-trend" style="color:${trendColor(intel.stablecoinNetflow)}">${trendArrow(intel.stablecoinNetflow)}</span></div>
                                <div class="intel-label">24h ç¨³å®šå¸å‡€æµå…¥ (USD)</div>
                            </div>
                        </div>
                    `;

                    if (intel.chainTvlChange !== null) {
                        html += `
                            <div class="intel-stat">
                                <div class="intel-icon">ğŸ”’</div>
                                <div>
                                    <div class="intel-value" style="color:${trendColor(intel.chainTvlChange)}">${formatPercent(intel.chainTvlChange)}</div>
                                    <div class="intel-label">24h é“¾ä¸ŠTVLå˜åŒ–</div>
                                </div>
                            </div>
                        `;
                    }

                    if (intel.chainDexVolume !== null) {
                        html += `
                            <div class="intel-stat">
                                <div class="intel-icon">ğŸ”„</div>
                                <div>
                                    <div class="intel-value">${formatLargeNumber(intel.chainDexVolume)}</div>
                                    <div class="intel-label">24h é“¾ä¸ŠDEXäº¤æ˜“é‡ (USD)</div>
                                </div>
                            </div>
                        `;
                    }

                    DOM.onchainIntelGrid.innerHTML = html;
                },
                renderWhaleActivity: (whaleData) => {
                    if (whaleData.length === 0) {
                        DOM.whaleActivityList.innerHTML = `<div class="error-message" style="padding: 10px;">æ— å·¨é²¸æ•°æ®</div>`;
                        return;
                    }
                    const html = whaleData.map(wallet => {
                        const balance = (wallet.balance / 1e18).toLocaleString(undefined, { maximumFractionDigits: 2 });
                        
                        const txsHtml = wallet.transactions.length > 0
                            ? wallet.transactions.map(tx => {
                                const isOut = tx.from.toLowerCase() === wallet.address.toLowerCase();
                                const dirIcon = isOut ? `<span style="color: var(--sell)">ğŸ“¤</span>` : `<span style="color: var(--buy)">ğŸ“¥</span>`;
                                const amount = (tx.value / 1e18).toFixed(2);
                                const time = new Date(tx.timeStamp * 1000).toLocaleString();
                                const shortAddr = (addr) => `${addr.slice(0, 6)}...${addr.slice(-4)}`;

                                return `
                                    <div class="whale-tx">
                                        <div class="whale-tx-dir">${dirIcon}</div>
                                        <div class="whale-tx-details">
                                            <div class="whale-tx-amount">${isOut ? 'è½¬å‡º' : 'è½¬å…¥'} ${amount} ETH</div>
                                            <div class="whale-tx-meta">
                                                <span>${time} | From: ${shortAddr(tx.from)} | To: ${shortAddr(tx.to)}</span>
                                                <a href="https://etherscan.io/tx/${tx.hash}" target="_blank">ğŸ”— æŸ¥çœ‹</a>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')
                            : `<div class="error-message" style="font-size: 12px; padding: 5px 0;">æš‚æ— è¿‘æœŸå¤§é¢äº¤æ˜“</div>`;

                        return `
                            <div class="whale-wallet-container">
                                <div class="whale-header">
                                    <span class="whale-name">${wallet.name}</span>
                                    <span class="whale-balance">ä½™é¢: ${balance} ETH</span>
                                </div>
                                ${txsHtml}
                            </div>
                        `;
                    }).join('');
                    DOM.whaleActivityList.innerHTML = html;
                },
                renderDexVolumes: (volumes) => {
                    const formatLargeNumber = (num) => {
                        if (num === null || num === undefined) return '-';
                        if (Math.abs(num) >= 1e9) return `$${(num / 1e9).toFixed(2)}B`;
                        if (Math.abs(num) >= 1e6) return `$${(num / 1e6).toFixed(2)}M`;
                        if (Math.abs(num) >= 1e3) return `$${(num / 1e3).toFixed(2)}K`;
                        return `$${num.toFixed(2)}`;
                    };
                    const trendColor = (val) => val >= 0 ? 'var(--buy)' : 'var(--sell)';

                    if (volumes.length === 0) {
                        DOM.dexVolumeList.innerHTML = `<div class="error-message" style="padding: 10px;">æ— DEXäº¤æ˜“é‡æ•°æ®</div>`;
                        return;
                    }

                    const html = volumes.map(dex => `
                        <div class="dex-row">
                            <span class="dex-name">${dex.displayName}</span>
                            <div class="dex-volume-details">
                                <div class="dex-volume">${formatLargeNumber(dex.total24h)}</div>
                                <div class="dex-change" style="color: ${trendColor(dex.change_1d)}">
                                    ${dex.change_1d !== null ? `${dex.change_1d.toFixed(2)}%` : '-'}
                                </div>
                            </div>
                        </div>
                    `).join('');
                    DOM.dexVolumeList.innerHTML = html;
                },
                 renderNews: (news) => {
                    if (!news || news.length === 0) {
                        DOM.newsListContainer.innerHTML = `<div class="error-message" style="padding: 10px;">æš‚æ— æ–°é—»</div>`;
                        return;
                    }
                    DOM.newsListContainer.innerHTML = news.map(item => `
                        <div class="news-item">
                            <a href="${item.url}" target="_blank" class="news-title">${item.title}</a>
                            <div class="news-source">${item.source}</div>
                        </div>
                    `).join('');
                },
                showError: (container, message) => {
                    container.innerHTML = `<div class="error-message">${message}</div>`;
                 }
            };

            // --- 3. CHARTING SETUP ---
            let kChart, candleSeries, vwapSeries, flowNetChart;
            function setupCharts() {
                kChart = LightweightCharts.createChart(DOM.kchartContainer, {
                    layout: { background: { type: 'solid', color: '#0b1220' }, textColor: '#cbd5e1' },
                    rightPriceScale: { borderColor: '#1f2937' }, timeScale: { borderColor: '#1f2937' },
                    grid: { vertLines: { color: '#1f2937' }, horzLines: { color: '#1f2937' } }
                });
                candleSeries = kChart.addCandlestickSeries({ upColor: '#22c55e', downColor: '#ef4444', borderVisible: false, wickUpColor: '#22c55e', wickDownColor: '#ef4444' });
                vwapSeries = kChart.addLineSeries({ color: '#eab308', lineWidth: 2, priceLineVisible: false });
                new ResizeObserver(() => kChart.timeScale().fitContent()).observe(DOM.kchartContainer);

                flowNetChart = new Chart($('flowNetChart'), {
                    type: 'bar',
                    data: { labels: [], datasets: [
                        { label: 'ä¸»åŠ¨ä¹°', data: [], backgroundColor: 'rgba(34, 197, 94, 0.7)', order: 2 },
                        { label: 'ä¸»åŠ¨å–', data: [], backgroundColor: 'rgba(239, 68, 68, 0.7)', order: 2 },
                        { type: 'line', label: 'å‡€ä¸»åŠ¨é‡', data: [], borderColor: '#60a5fa', borderWidth: 2, tension: 0.4, yAxisID: 'y1', order: 1 }
                    ]},
                    options: {
                        responsive: true, maintainAspectRatio: false, animation: { duration: 0 },
                        scales: {
                            x: { type: 'time', time: { unit: 'minute' }, grid: { color: '#1f2937' }, ticks: { color: '#94a3b8' } },
                            y: { beginAtZero: true, grid: { color: '#1f2937' }, ticks: { color: '#94a3b8' }, stacked: true },
                            y1: { position: 'right', grid: { display: false }, ticks: { color: '#94a3b8' } }
                        },
                        plugins: { legend: { display: false }, tooltip: { mode: 'index', intersect: false } }
                    }
                });
            }

            // --- 4. DATA & API ---
            async function fetchData(url, errorMsg) {
                try {
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return await res.json();
                } catch (e) { console.error(errorMsg, e); throw e; }
            }
            async function fetchKlines() {
                const url = `${CONFIG.api.binanceRest}/klines?symbol=${STATE.symbol}&interval=${STATE.kInterval}&limit=500`;
                const data = await fetchData(url, 'K-lines fetch failed');
                return data.map(k => ({ time: k[0]/1000, open: +k[1], high: +k[2], low: +k[3], close: +k[4], volume: +k[5] }));
            }
            async function fetch24hStats() {
                const url = `${CONFIG.api.binanceRest}/ticker/24hr?symbol=${STATE.symbol}`;
                try {
                    const d = await fetchData(url, 'Failed to fetch 24h stats');
                    const chg = (+d.priceChangePercent).toFixed(2);
                    DOM.lastPrice.textContent = (+d.lastPrice).toLocaleString(undefined, { maximumFractionDigits: 2 });
                    DOM.change24h.textContent = `${chg > 0 ? '+' : ''}${chg}%`;
                    DOM.change24h.style.color = chg >= 0 ? 'var(--buy)' : 'var(--sell)';
                } catch {
                    DOM.lastPrice.textContent = '-';
                    DOM.change24h.textContent = '-';
                }
            }
            
            async function fetchAllOnchainData() {
                // 1. Fetch stablecoin data
                try {
                    const stablecoinUrl = `https://stablecoins.llama.fi/stablecoincharts/all`;
                    const data = await fetchData(stablecoinUrl, 'DefiLlama Stablecoin API fetch failed');
                    
                    if (!Array.isArray(data) || data.length < 2) {
                        throw new Error("Invalid or insufficient data from DefiLlama stablecoin charts");
                    }

                    const latestDataPoint = data[data.length - 1];
                    const previousDataPoint = data[data.length - 2];

                    const latestCirculation = latestDataPoint?.totalCirculating?.peggedUSD;
                    const previousCirculation = previousDataPoint?.totalCirculating?.peggedUSD;

                    if (latestCirculation !== undefined && previousCirculation !== undefined) {
                        STATE.onchainIntel.stablecoinNetflow = latestCirculation - previousCirculation;
                    } else {
                        throw new Error("Unexpected data structure in stablecoin charts response");
                    }

                } catch (error) {
                    console.error("Failed to process stablecoin data:", error);
                    STATE.onchainIntel.stablecoinNetflow = 0;
                }

                // 2. Fetch Chain-specific data
                const symbolInfo = CONFIG.symbols[STATE.symbol];
                if (!symbolInfo || !symbolInfo.chain) {
                    STATE.onchainIntel.chainTvlChange = null;
                    STATE.onchainIntel.chainDexVolume = null;
                    UI.renderOnchainIntel(STATE.onchainIntel);
                    return;
                }
                const chain = symbolInfo.chain;

                try {
                    const tvlUrl = `${CONFIG.api.defiLlama}/v2/historicalChainTvl/${chain}`;
                    const tvlData = await fetchData(tvlUrl, 'DefiLlama TVL API fetch failed');
                    if (tvlData && tvlData.length >= 2) {
                        const lastTvl = tvlData[tvlData.length - 1].tvl;
                        const prevTvl = tvlData[tvlData.length - 2].tvl;
                        STATE.onchainIntel.chainTvlChange = prevTvl > 0 ? (lastTvl - prevTvl) / prevTvl : 0;
                    } else {
                        STATE.onchainIntel.chainTvlChange = null;
                    }

                    const volumeUrl = `${CONFIG.api.defiLlama}/overview/dexs/${chain}?excludeTotalDataChartBreakdown=true&excludeProtocolList=true`;
                    const volumeData = await fetchData(volumeUrl, 'DefiLlama DEX Volume API fetch failed');
                    if (volumeData && Array.isArray(volumeData.totalDataChart) && volumeData.totalDataChart.length > 0) {
                        STATE.onchainIntel.chainDexVolume = volumeData.totalDataChart[volumeData.totalDataChart.length - 1][1];
                    } else {
                         STATE.onchainIntel.chainDexVolume = null;
                    }
                } catch (error) {
                    console.error("Failed to fetch chain-specific on-chain data:", error);
                    STATE.onchainIntel.chainTvlChange = null;
                    STATE.onchainIntel.chainDexVolume = null;
                }

                // 3. Render all data
                UI.renderOnchainIntel(STATE.onchainIntel);
            }

            async function fetchWhaleActivity() {
                if (CONFIG.symbols[STATE.symbol].chain !== 'Ethereum') {
                    DOM.whaleActivityList.innerHTML = `<div class="error-message" style="padding: 10px;">å½“å‰ä»…æ”¯æŒè·Ÿè¸ªä»¥å¤ªåŠå·¨é²¸</div>`;
                    STATE.whaleData = [];
                    return;
                }

                DOM.whaleActivityList.innerHTML = `<div class="loader-text" style="text-align:center; padding: 20px;">åŠ è½½å·¨é²¸åŠ¨æ€ä¸­...</div>`;

                try {
                    let whaleData = CONFIG.whaleWallets.map(w => ({ ...w, balance: 0, transactions: [] }));
                    const addresses = CONFIG.whaleWallets.map(w => w.address).join(',');

                    const balanceUrl = `${CONFIG.api.etherscan}?module=account&action=balancemulti&address=${addresses}&tag=latest&apikey=${CONFIG.etherscanApiKey}`;
                    const balanceRes = await fetchData(balanceUrl, 'Etherscan balance API failed');
                    if (balanceRes.status === "1") {
                        balanceRes.result.forEach(bal => {
                            const wallet = whaleData.find(w => w.address.toLowerCase() === bal.account.toLowerCase());
                            if (wallet) {
                                wallet.balance = parseFloat(bal.balance);
                            }
                        });
                    }

                    const txPromises = CONFIG.whaleWallets.map(wallet => {
                        const url = `${CONFIG.api.etherscan}?module=account&action=txlist&address=${wallet.address}&startblock=0&endblock=99999999&page=1&offset=50&sort=desc&apikey=${CONFIG.etherscanApiKey}`;
                        return fetchData(url, `Etherscan txlist API failed for ${wallet.address}`);
                    });
                    const txResults = await Promise.all(txPromises);

                    const sevenDaysAgo = Date.now() / 1000 - 7 * 24 * 60 * 60;
                    const whaleTxThreshold = 100 * 1e18; 

                    txResults.forEach((res, index) => {
                        if (res.status === "1") {
                            const walletAddress = CONFIG.whaleWallets[index].address;
                            const wallet = whaleData.find(w => w.address === walletAddress);
                            if (wallet) {
                                wallet.transactions = res.result
                                    .filter(tx => tx.timeStamp > sevenDaysAgo && parseFloat(tx.value) > whaleTxThreshold)
                                    .slice(0, 5);
                            }
                        }
                    });

                    STATE.whaleData = whaleData;
                    UI.renderWhaleActivity(STATE.whaleData);

                } catch (error) {
                    console.error("Failed to fetch or process whale activity:", error);
                    UI.showError(DOM.whaleActivityList, 'å·¨é²¸åŠ¨æ€åŠ è½½å¤±è´¥');
                    STATE.whaleData = [];
                }
            }

            async function fetchDexVolumes() {
                DOM.dexVolumeList.innerHTML = `<div class="loader-text" style="text-align:center; padding: 20px;">åŠ è½½DEXæ’è¡Œä¸­...</div>`;
                try {
                    const url = `${CONFIG.api.defiLlama}/overview/dexs?excludeTotalDataChart=true&excludeTotalDataChartBreakdown=true`;
                    const data = await fetchData(url, 'DefiLlama DEX overview API fetch failed');
                    
                    if (data && Array.isArray(data.protocols)) {
                        const sortedDexs = data.protocols
                            .sort((a, b) => b.total24h - a.total24h)
                            .slice(0, 5);
                        STATE.dexVolumes = sortedDexs;
                        UI.renderDexVolumes(sortedDexs);
                    } else {
                        throw new Error("Invalid data format from DEX overview API");
                    }
                } catch (error) {
                    console.error("Failed to fetch DEX volumes:", error);
                    UI.showError(DOM.dexVolumeList, 'DEXæ’è¡ŒåŠ è½½å¤±è´¥');
                    STATE.dexVolumes = [];
                }
            }


            async function fetchNews(symbol) {
                DOM.newsListContainer.innerHTML = `<div class="loader-text" style="text-align:center; padding: 20px;">åŠ è½½æ–°é—»ä¸­...</div>`;
                const coin = symbol.replace('USDT', '');
                const url = `${CONFIG.api.cryptoCompare}?lang=EN&categories=${coin}`;
                
                try {
                    const response = await fetchData(url, 'CryptoCompare News API fetch failed');
                    if (response.Type !== 100) {
                        throw new Error(response.Message);
                    }
                    
                    const newsData = response.Data.slice(0, 5).map(article => ({
                        title: article.title,
                        source: article.source_info.name,
                        url: article.url
                    }));

                    STATE.news = newsData;
                    UI.renderNews(newsData);
                    return newsData;

                } catch (error) {
                    console.error("Failed to fetch or process news:", error);
                    UI.showError(DOM.newsListContainer, 'æ–°é—»èµ„è®¯åŠ è½½å¤±è´¥');
                    STATE.news = [];
                    return [];
                }
            }


            // --- 5. REAL-TIME & FLOW LOGIC ---
            function openStream() {
                if (STATE.ws) closeStream();
                UI.updateStatus('connecting');
                const stream = `${STATE.symbol.toLowerCase()}@aggTrade/${STATE.symbol.toLowerCase()}@kline_${STATE.kInterval}`;
                STATE.ws = new WebSocket(`${CONFIG.api.binanceWs}?streams=${stream}`);
                
                STATE.ws.onopen = () => UI.updateStatus('connected');
                STATE.ws.onmessage = handleWsMessage;
                STATE.ws.onclose = handleReconnect;
                STATE.ws.onerror = handleReconnect;
            }
            
            function closeStream() {
                if (STATE.ws) {
                    STATE.ws.onclose = null;
                    STATE.ws.close();
                    STATE.ws = null;
                }
                if (STATE.reconnectTimer) clearTimeout(STATE.reconnectTimer);
            }

            function handleReconnect() {
                UI.updateStatus('disconnected');
                if (STATE.reconnectTimer) return;
                STATE.reconnectTimer = setTimeout(() => {
                    STATE.reconnectTimer = null;
                    openStream();
                }, 3000);
            }

            function handleWsMessage(event) {
                if (STATE.isPaused) return;
                const msg = JSON.parse(event.data);
                if (msg.stream.endsWith('aggTrade')) processAggTrade(msg.data);
                else if (msg.stream.includes('@kline_')) processKline(msg.data.k);
            }

            function processAggTrade(data) {
                const qty = parseFloat(data.q);
                const ts = data.T || data.E;
                const bTs = Math.floor(ts / STATE.bucketMs) * STATE.bucketMs;
                const bucket = STATE.buckets.get(bTs) || { buy: 0, sell: 0 };
                data.m ? (bucket.sell += qty) : (bucket.buy += qty);
                STATE.buckets.set(bTs, bucket);

                const currentBucket = STATE.buckets.get(Math.floor(Date.now() / STATE.bucketMs) * STATE.bucketMs) || { buy: 0, sell: 0 };
                DOM.buyNow.textContent = currentBucket.buy.toFixed(4);
                DOM.sellNow.textContent = currentBucket.sell.toFixed(4);
                DOM.netNow.textContent = (currentBucket.buy - currentBucket.sell).toFixed(4);
                
                updateFlowChart();
            }

            function processKline(k) {
                const klineData = { time:k.t/1000, open:+k.o, high:+k.h, low:+k.l, close:+k.c, volume:+k.v };
                candleSeries.update(klineData);
                DOM.lastPrice.textContent = (+k.c).toLocaleString(undefined, { maximumFractionDigits: 2 });
                const lastKline = STATE.klineHistory[STATE.klineHistory.length - 1];
                if (lastKline && lastKline.time === klineData.time) STATE.klineHistory[STATE.klineHistory.length - 1] = klineData;
                else { STATE.klineHistory.push(klineData); if (STATE.klineHistory.length > 500) STATE.klineHistory.shift(); }
                
                const vwapData = TechnicalIndicators.calculateVWAP(STATE.klineHistory);
                if (vwapData.length > 0) vwapSeries.update(vwapData[vwapData.length - 1]);
            }

            function updateFlowChart() {
                if(STATE.isRafPending) return;
                STATE.isRafPending = true;
                requestAnimationFrame(() => {
                    const entries = Array.from(STATE.buckets.entries()).sort((a,b)=>a[0]-b[0]).slice(-CONFIG.charts.maxDataPoints);
                    flowNetChart.data.labels = entries.map(([t])=>new Date(t));
                    flowNetChart.data.datasets[0].data = entries.map(([,v])=>v.buy);
                    flowNetChart.data.datasets[1].data = entries.map(([,v])=>v.sell);
                    flowNetChart.data.datasets[2].data = entries.map(([,v])=>v.buy-v.sell);
                    flowNetChart.update('none');
                    STATE.isRafPending = false;
                });
            }

            function resetFlowData() {
                STATE.buckets.clear();
                flowNetChart.data.labels = [];
                flowNetChart.data.datasets.forEach(ds => ds.data = []);
                flowNetChart.update('none');
                DOM.buyNow.textContent = '-';
                DOM.sellNow.textContent = '-';
                DOM.netNow.textContent = '-';
            }
            
            // --- 6. AI ENGINE ---
            class TechnicalIndicators {
                static calculateRSI(prices, period = 14) {
                    if (prices.length <= period) return null;
                    let gains = 0, losses = 0;
                    for (let i = 1; i <= period; i++) {
                        const diff = prices[i] - prices[i-1];
                        if (diff > 0) gains += diff; else losses -= diff;
                    }
                    let avgGain = gains / period;
                    let avgLoss = losses / period;
                    for (let i = period + 1; i < prices.length; i++) {
                        const diff = prices[i] - prices[i-1];
                        avgGain = (avgGain * (period - 1) + (diff > 0 ? diff : 0)) / period;
                        avgLoss = (avgLoss * (period - 1) + (diff < 0 ? -diff : 0)) / period;
                    }
                    if (avgLoss === 0) return 100;
                    const rs = avgGain / avgLoss;
                    return 100 - (100 / (1 + rs));
                }
                static calculateLastEMA(data, period) {
                    if (data.length < period) return null;
                    const multiplier = 2 / (period + 1);
                    let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
                    for (let i = period; i < data.length; i++) {
                        ema = (data[i] * multiplier) + (ema * (1 - multiplier));
                    }
                    return ema;
                }
                static calculateMACD(prices, fast=12, slow=26, signal=9) {
                    if (prices.length < slow) return null;
                    const emaFast = this.calculateLastEMA(prices, fast);
                    const emaSlow = this.calculateLastEMA(prices, slow);
                    if (emaFast === null || emaSlow === null) return null;
                    
                    const macdLine = emaFast - emaSlow;

                    const fullEmaFast = this.calculateFullEMA(prices, fast);
                    const fullEmaSlow = this.calculateFullEMA(prices, slow);
                    const macdLineHistory = fullEmaSlow.map((slowVal, i) => slowVal !== null ? fullEmaFast[i] - slowVal : null).filter(v => v !== null);
                    
                    if (macdLineHistory.length < signal) return null;
                    
                    const signalLine = this.calculateLastEMA(macdLineHistory, signal);
                    if (signalLine === null) return null;

                    return { macd: macdLine, signal: signalLine, histogram: macdLine - signalLine };
                }
                static calculateFullEMA(data, period) {
                    const multiplier = 2 / (period + 1);
                    const emaArray = [];
                    if (data.length >= period) {
                        let initialSma = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
                        emaArray.push(initialSma);
                        for (let i = period; i < data.length; i++) {
                            const currentEma = (data[i] * multiplier) + (emaArray[emaArray.length-1] * (1 - multiplier));
                            emaArray.push(currentEma);
                        }
                    }
                    return Array(data.length - emaArray.length).fill(null).concat(emaArray);
                }
                static calculateBollingerBands(prices, period = 20, stdDev = 2) {
                    if (prices.length < period) return null;
                    const slice = prices.slice(-period);
                    const sma = slice.reduce((a, b) => a + b) / period;
                    const variance = slice.reduce((a, b) => a + Math.pow(b - sma, 2), 0) / period;
                    const sd = Math.sqrt(variance);
                    return { middle: sma, upper: sma + (sd * stdDev), lower: sma - (sd * stdDev) };
                }
                static calculateVWAP(candles) {
                    let cumulativeTypicalPriceVolume = 0;
                    let cumulativeVolume = 0;
                    let lastDate = null;
                    return candles.map(c => {
                        const currentDate = new Date(c.time * 1000).getUTCDate();
                        if (lastDate !== null && currentDate !== lastDate) {
                            cumulativeTypicalPriceVolume = 0;
                            cumulativeVolume = 0;
                        }
                        const typicalPrice = (c.high + c.low + c.close) / 3;
                        cumulativeTypicalPriceVolume += typicalPrice * c.volume;
                        cumulativeVolume += c.volume;
                        lastDate = currentDate;
                        return { time: c.time, value: cumulativeVolume > 0 ? cumulativeTypicalPriceVolume / cumulativeVolume : typicalPrice };
                    });
                }
                 static calculateSupportResistance(candles, lookback = 50) {
                    if (candles.length < lookback) return { support: null, resistance: null };
                    const recentCandles = candles.slice(-lookback);
                    let lowestLow = Infinity, highestHigh = -Infinity;
                    
                    recentCandles.forEach(c => {
                        if(c.low < lowestLow) lowestLow = c.low;
                        if(c.high > highestHigh) highestHigh = c.high;
                    });
                    
                    return { support: lowestLow, resistance: highestHigh };
                }
            }
            class TradingSignalEngine {
                generateSignals(onchainIntel) {
                    const candles = STATE.klineHistory;
                    if (candles.length < 50) return { score: null, summary: 'æ•°æ®ä¸è¶³', breakdown: {}, metrics: {} };
                    
                    const prices = candles.map(c => c.close);
                    const currentPrice = prices[prices.length - 1];
                    
                    const rsi = TechnicalIndicators.calculateRSI(prices);
                    const macd = TechnicalIndicators.calculateMACD(prices);
                    const bb = TechnicalIndicators.calculateBollingerBands(prices);
                    const ema20 = TechnicalIndicators.calculateLastEMA(prices, 20);
                    const ema50 = TechnicalIndicators.calculateLastEMA(prices, 50);
                    const vwap = TechnicalIndicators.calculateVWAP(candles).slice(-1)[0]?.value;
                    const sr = TechnicalIndicators.calculateSupportResistance(candles);

                    let score = 50;
                    const breakdown = {};

                    // Technical Indicators Scoring
                    if (rsi) {
                        if (rsi < 30) { score += 15; breakdown.RSI = { signal: 'buy', reason: 'è¶…å–åŒºåŸŸ (<30)' }; } 
                        else if (rsi > 70) { score -= 15; breakdown.RSI = { signal: 'sell', reason: 'è¶…ä¹°åŒºåŸŸ (>70)' }; }
                        else { score += (50 - rsi) * 0.3; breakdown.RSI = { signal: 'neutral', reason: `ä¸­æ€§åŒºåŸŸ (${rsi.toFixed(1)})` }; }
                    }
                    if (macd) {
                        if (macd.histogram > 0) { score += 10; breakdown.MACD = { signal: 'buy', reason: 'æŸ±çŠ¶å›¾ä¸ºæ­£ (çœ‹æ¶¨)' }; }
                        else if (macd.histogram < 0) { score -= 10; breakdown.MACD = { signal: 'sell', reason: 'æŸ±çŠ¶å›¾ä¸ºè´Ÿ (çœ‹è·Œ)' }; }
                        else { breakdown.MACD = { signal: 'neutral', reason: 'ä¿¡å·äº¤å‰' }; }
                    }
                    if (ema20 && ema50) {
                        if (ema20 > ema50) { score += 10; breakdown.EMA = { signal: 'buy', reason: 'çŸ­æœŸå‡çº¿ä¸Šç©¿é•¿æœŸå‡çº¿' }; }
                        else { score -= 10; breakdown.EMA = { signal: 'sell', reason: 'çŸ­æœŸå‡çº¿ä¸‹ç©¿é•¿æœŸå‡çº¿' }; }
                    }
                    if (bb) {
                        if (currentPrice < bb.lower) { score += 5; breakdown.BB = { signal: 'buy', reason: 'ä»·æ ¼è§¦åŠä¸‹è½¨' }; }
                        else if (currentPrice > bb.upper) { score -= 5; breakdown.BB = { signal: 'sell', reason: 'ä»·æ ¼è§¦åŠä¸Šè½¨' }; }
                        else { breakdown.BB = { signal: 'neutral', reason: 'ä»·æ ¼åœ¨é€šé“å†…' }; }
                    }
                    if (vwap) {
                        if (currentPrice > vwap) { score += 5; breakdown.VWAP = { signal: 'buy', reason: 'ä»·æ ¼åœ¨VWAPä¹‹ä¸Š' }; }
                        else if (currentPrice < vwap) { score -= 5; breakdown.VWAP = { signal: 'sell', reason: 'ä»·æ ¼åœ¨VWAPä¹‹ä¸‹' }; }
                        else { breakdown.VWAP = { signal: 'neutral', reason: 'ä»·æ ¼æ¥è¿‘VWAP' }; }
                    }
                    
                    // On-chain Indicators Scoring
                    let onchainSignal = 'neutral';
                    let onchainReason = 'é“¾ä¸Šèµ„é‡‘æµåŠ¨å¹³ç¨³';
                    if(onchainIntel.stablecoinNetflow > 20e6) {
                        score += 15;
                        onchainSignal = 'buy';
                        onchainReason = 'ç¨³å®šå¸å‘ˆæ˜¾è‘—å‡€æµå…¥';
                    } else if (onchainIntel.stablecoinNetflow < -20e6) {
                        score -= 15;
                        onchainSignal = 'sell';
                        onchainReason = 'ç¨³å®šå¸å‘ˆæ˜¾è‘—å‡€æµå‡º';
                    }
                    breakdown['èµ„é‡‘æµ'] = { signal: onchainSignal, reason: onchainReason };

                    if (onchainIntel.chainTvlChange !== null) {
                        let tvlSignal = 'neutral';
                        let tvlReason = `TVL 24h å˜åŒ–: ${(onchainIntel.chainTvlChange * 100).toFixed(2)}%`;
                        if (onchainIntel.chainTvlChange > 0.02) {
                            score += 10;
                            tvlSignal = 'buy';
                            tvlReason = `TVL æ˜¾è‘—å¢é•¿ (+${(onchainIntel.chainTvlChange * 100).toFixed(2)}%)`;
                        } else if (onchainIntel.chainTvlChange < -0.02) {
                            score -= 10;
                            tvlSignal = 'sell';
                            tvlReason = `TVL æ˜¾è‘—ä¸‹é™ (${(onchainIntel.chainTvlChange * 100).toFixed(2)}%)`;
                        }
                        breakdown['é“¾TVL'] = { signal: tvlSignal, reason: tvlReason };
                    }

                    if (onchainIntel.chainDexVolume !== null) {
                        breakdown['é“¾ä¸Šäº¤æ˜“é‡'] = { signal: 'neutral', reason: `24h äº¤æ˜“é‡: ${(onchainIntel.chainDexVolume / 1e9).toFixed(2)}B` };
                        if (onchainIntel.chainDexVolume > 1e9) {
                            score += 5;
                        }
                    }

                    score = Math.max(0, Math.min(100, Math.round(score)));
                    
                    let summary = "å¸‚åœºæƒ…ç»ªä¸­æ€§ï¼Œå»ºè®®è§‚å¯Ÿã€‚";
                    if (score > 75) summary = "AIå»ºè®®ï¼šå¸‚åœºæåº¦çœ‹æ¶¨ï¼Œå¯»æ‰¾ä¹°å…¥ç‚¹ã€‚";
                    else if (score > 60) summary = "AIå»ºè®®ï¼šå¸‚åœºåå‘çœ‹æ¶¨ï¼Œå¯è€ƒè™‘é€¢ä½åšå¤šã€‚";
                    else if (score < 25) summary = "AIå»ºè®®ï¼šå¸‚åœºæåº¦çœ‹è·Œï¼Œæ³¨æ„é£é™©ã€‚";
                    else if (score < 40) summary = "AIå»ºè®®ï¼šå¸‚åœºåå‘çœ‹è·Œï¼Œæ“ä½œéœ€è°¨æ…ã€‚";
                    
                    let buyPrice = null, sellPrice = null;
                    if (score > 60) buyPrice = sr.support || bb.lower;
                    if (score < 40) sellPrice = sr.resistance || bb.upper;

                    const trend = ema20 > ema50 ? 'bullish' : (ema20 < ema50 ? 'bearish' : 'neutral');
                    const risk = (rsi > 80 || rsi < 20) ? 'high' : (bb && (currentPrice > bb.upper || currentPrice < bb.lower)) ? 'medium' : 'low';
                    const fearGreedIndex = Math.round(rsi ? (100 - rsi) * 0.5 + (score / 100) * 50 : 50);

                    const metrics = {
                        buyPrice, sellPrice,
                        support: sr.support,
                        resistance: sr.resistance,
                        trend,
                        risk,
                        fearGreedIndex
                    };
                    
                    STATE.lastAnalysis = { score, summary, breakdown, metrics };
                    return STATE.lastAnalysis;
                }
            }
            const signalEngine = new TradingSignalEngine();

            // --- 7. GEMINI API INTEGRATION ---
            async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(url, options);
                        if (!response.ok) {
                           if (response.status === 429 || response.status >= 500) {
                               throw new Error(`API Error: ${response.status}`);
                           }
                        }
                        return response;
                    } catch (error) {
                        if (i === retries - 1) throw error;
                        await new Promise(res => setTimeout(res, delay * Math.pow(2, i)));
                    }
                }
            }
            
            async function generateAiAnalysisReport() {
                DOM.geminiBtn.disabled = true;
                DOM.geminiBtn.textContent = 'åˆ†æä¸­...';
                DOM.geminiPredictionContainer.innerHTML = `<div class="gemini-prediction"><div class="v">Gemini æ­£åœ¨åˆ†ææ•°æ®...</div></div>`;

                const { breakdown, metrics } = STATE.lastAnalysis;
                const newsHeadlines = STATE.news.map(n => n.title).join('; ');
                
                let whaleSummary = "æ²¡æœ‰è§‚å¯Ÿåˆ°æ˜¾è‘—çš„å·¨é²¸æ´»åŠ¨ã€‚";
                if (STATE.whaleData.length > 0) {
                    const allTxs = STATE.whaleData.flatMap(w => w.transactions.map(tx => ({...tx, monitoredAddress: w.address})));
                    const buys = allTxs.filter(tx => tx.to.toLowerCase() === tx.monitoredAddress.toLowerCase()).length;
                    const sells = allTxs.filter(tx => tx.from.toLowerCase() === tx.monitoredAddress.toLowerCase()).length;
                    if (buys > 0 || sells > 0) {
                        whaleSummary = `æœ€è¿‘è§‚å¯Ÿåˆ° ${buys} ç¬”å·¨é²¸å¤§é¢ä¹°å…¥å’Œ ${sells} ç¬”å¤§é¢å–å‡ºã€‚`;
                    }
                }
                
                const formatLargeNumber = (num) => {
                    if (num === null || num === undefined) return '-';
                    if (Math.abs(num) >= 1e9) return `$${(num / 1e9).toFixed(2)}B`;
                    if (Math.abs(num) >= 1e6) return `$${(num / 1e6).toFixed(2)}M`;
                    return `$${(num/1e3).toFixed(2)}K`;
                };
                const dexSummary = STATE.dexVolumes.slice(0, 3).map(d => `${d.displayName}: ${formatLargeNumber(d.total24h)}`).join(', ');


                const prompt = `
                    You are a professional cryptocurrency quantitative analyst. Your task is to provide a structured prediction based on the provided real-time data and recent news. Respond ONLY with a valid JSON object.

                    Data for ${STATE.symbol} (${CONFIG.klineIntervals[STATE.kInterval]} timeframe):
                    - Current Price: ${DOM.lastPrice.textContent}
                    - 24h Change: ${DOM.change24h.textContent}
                    - Trend Signal: ${metrics.trend}
                    - Risk Level: ${metrics.risk}
                    - Fear & Greed Index: ${metrics.fearGreedIndex}
                    - Key Indicators: ${JSON.stringify(breakdown)}
                    - On-Chain Signal: ${breakdown['èµ„é‡‘æµ']?.reason}
                    - Recent Whale Activity: ${whaleSummary}
                    - Top DEX Volumes (24h): ${dexSummary}
                    - Recent News Headlines: ${newsHeadlines}

                    Based on a comprehensive analysis of ALL the provided data (technical, on-chain, whale activity, DEX volumes, and news), provide a structured forecast in the following JSON format.
                `;

                try {
                    const apiKey = ""; // Will be provided by the environment
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    
                    const payload = {
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    pricePrediction: { type: "STRING", description: "A short, specific price prediction in Chinese, considering all data. e.g., 'åœ¨å®è§‚åˆ©å¥½æ¶ˆæ¯æ¨åŠ¨ä¸‹ï¼Œå¯èƒ½çªç ´$70,000' or 'æŠ€æœ¯é¢çœ‹è·Œï¼Œæˆ–å°†å›è°ƒè‡³$65,000æ”¯æ’‘åŒºåŸŸ'." },
                                    confidence: { type: "NUMBER", description: "Confidence level for the prediction, from 1 (low) to 5 (high)." },
                                    strategySuggestion: { type: "STRING", description: "A concise, actionable trading suggestion in Chinese, considering all data. e.g., 'å»ºè®®åœ¨å›è°ƒè‡³æ”¯æ’‘ä½é™„è¿‘æ—¶å¯»æ‰¾ä¹°å…¥æœºä¼šï¼Œä½†éœ€å…³æ³¨æ–°é—»é¢å˜åŒ–ã€‚'" }
                                }
                            }
                        }
                    };

                    const response = await fetchWithRetry(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                    
                    const result = await response.json();
                    if (!result.candidates || result.candidates.length === 0) {
                        throw new Error("No valid response from Gemini API.");
                    }
                    const predictionJson = JSON.parse(result.candidates[0].content.parts[0].text);
                    UI.renderGeminiPrediction(predictionJson);

                } catch (error) {
                    console.error("Gemini API call failed:", error);
                    DOM.geminiPredictionContainer.innerHTML = `<div class="error-message">AI é¢„æµ‹å¤±è´¥</div>`;
                } finally {
                    DOM.geminiBtn.disabled = false;
                    DOM.geminiBtn.textContent = 'âœ¨ ç”ŸæˆAIæ·±åº¦åˆ†æ';
                }
            }


            // --- 8. INITIALIZATION ---
            function runPredictionEngine() {
                if (STATE.predictionUpdateInterval) clearInterval(STATE.predictionUpdateInterval);
                const update = () => {
                    if (STATE.klineHistory.length > 50) {
                        const { score, summary, breakdown, metrics } = signalEngine.generateSignals(STATE.onchainIntel);
                        UI.renderAiAnalysis(score, summary);
                        UI.renderAiBreakdown(breakdown);
                        UI.renderAiMetrics(metrics);
                    }
                };
                update();
                STATE.predictionUpdateInterval = setInterval(update, 5000);
            }
            
            async function handleControlChange() {
                [DOM.symbol, DOM.bucket, DOM.kInterval, DOM.resetBtn].forEach(el => el.disabled = true);
                STATE.symbol = DOM.symbol.value;
                STATE.bucketMs = +DOM.bucket.value;
                STATE.kInterval = DOM.kInterval.value;
                try {
                    await initialize();
                } catch (error) {
                    console.error("Failed to re-initialize dashboard:", error);
                } finally {
                    [DOM.symbol, DOM.bucket, DOM.kInterval, DOM.resetBtn].forEach(el => el.disabled = false);
                }
            }

            function setupEventListeners() {
                DOM.symbol.addEventListener('change', handleControlChange);
                DOM.bucket.addEventListener('change', handleControlChange);
                DOM.kInterval.addEventListener('change', handleControlChange);
                DOM.resetBtn.addEventListener('click', handleControlChange);
                
                DOM.pauseBtn.addEventListener('click', () => {
                    STATE.isPaused = !STATE.isPaused;
                    DOM.pauseBtn.innerHTML = STATE.isPaused ? 'â–¶ï¸ ç»§ç»­' : 'â¯ï¸ æš‚åœ';
                    DOM.pauseBtn.title = STATE.isPaused ? 'æ¢å¤æ•°æ®æ›´æ–°' : 'æš‚åœæ•°æ®æ›´æ–°';
                });

                DOM.geminiBtn.addEventListener('click', generateAiAnalysisReport);
            }

            async function initialize() {
                if (STATE.ws) closeStream();
                resetFlowData();
                UI.updateTitles();
                UI.toggleLoader(DOM.kchartLoader, true);
                UI.toggleLoader(DOM.predictionLoader, true);
                if (STATE.predictionUpdateInterval) clearInterval(STATE.predictionUpdateInterval);
                DOM.aiAnalysisContainer.innerHTML = '';
                DOM.aiBreakdownContainer.innerHTML = '';
                DOM.aiMetricsContainer.innerHTML = '';
                DOM.geminiPredictionContainer.innerHTML = '';
                
                // Fetch all data concurrently
                fetchAllOnchainData();
                fetchWhaleActivity();
                fetchDexVolumes();
                fetchNews(STATE.symbol);

                try {
                    const klineData = await fetchKlines();
                    await fetch24hStats();
                    
                    STATE.klineHistory = klineData;
                    candleSeries.setData(klineData);
                    const vwapData = TechnicalIndicators.calculateVWAP(klineData);
                    vwapSeries.setData(vwapData);
                    kChart.timeScale().fitContent();
                    
                    runPredictionEngine();
                    openStream();
                    
                } catch (error) {
                    console.error("Critical initialization failed:", error);
                    UI.showError(DOM.kchartContainer, 'åˆå§‹åŒ–Kçº¿æ•°æ®å¤±è´¥');
                    UI.showError(DOM.aiAnalysisContainer, 'AIå¼•æ“å¯åŠ¨å¤±è´¥');
                    UI.updateStatus('disconnected');
                    throw error;
                } finally {
                    UI.toggleLoader(DOM.kchartLoader, false);
                    UI.toggleLoader(DOM.predictionLoader, false);
                }
            }

            document.addEventListener('DOMContentLoaded', () => {
                setupCharts();
                UI.populateSelects();
                setupEventListeners();
                initialize();
            });
        })();
    </script>
</body>
</html>
